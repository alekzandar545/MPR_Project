# Матричен сървър с мултитрединг

## Описание

Този проект реализира клиент-сървър архитектура за попълване на 2d матрици. Сървърът приема заявки от клиенти, създава и запълва матрици, и връща резултатите обратно към клиента. Проектът демонстрира използването на:

- Многонишкова обработка на големи матрици.
- Thread pool за ефективно управление на клиентски заявки.
- RAII принципи за управление на ресурси (сокети, нишки).
- Thread-safe логване на всички важни действия.
- Валидация на входни параметри и ограничение на размера на матриците.

---

## Функционалности

- **Мултитрединг и бенчмаркване:** Сравнение между еднонишкова и многонишкова обработка на матрици.
- **Thread pool:** Всички клиентски заявки се обработват чрез thread pool, който се грижи за оптимална работа с ресурсите.
- **Логове:** Сървърът логва всички важни събития (приемане на клиент, получени параметри, грешки, изключения).
- **"graceful" изключване:** Ctrl+C прекратява сървъра, като завършва обработката на текущите клиенти и затваря сокетите.
- **Валидация на вход:** Параметри за редове, колони и брой нишки се проверяват за допустимост.
- **Ограничения:** Максимален брой елементи в матрицата (~100 000 000)
- **Свързване** Клиентът може да прави многократни опити за връзка в сървъра, в случай че тя е неуспешна

---

## Инструкции за компилиране и стартиране

### Изисквания

- Windows OS (използва Winsock2)
- Visual Studio или MinGW
- CMake (в PATH или локално)
- Поддържка на C++17 или по-нова версия

### Компилация
 - Чрез стартиране на run.bat посредством CMake проектът се компилира

### Стартиране
 - Чрез start_server.bat се стартира сървърът
 - Чрез start_client.bat се създава нов клиент, който се свързва към сървъра

### Приключване
 - Клиентите приключват своята работа, когато успешно/неуспешно изпратят своята заявка на сървъра
 - Сървърът приключва своята работа при CTRL+C, като при това първо ще спре да приема нови клиенти, после ще дообработи вече свързаните и накрая ще се затвори

## Основни стъпки при реализиране на проекта

Реализацията на проекта е извършена поетапно, като е следван обектно-ориентиран и модулен подход. 

---

### 1. Изграждане на базова клиент–сървър комуникация

Първата стъпка беше създаването на TCP клиент и сървър, използвайки Winsock. Реализирани бяха:

- създаване и валидиране на сокети;
- свързване на клиента със сървъра;
- приемане на клиентски връзки от страна на сървъра.

Това постави основата за по-нататъшна комуникация и обмен на данни.

---

### 2. Дефиниране на комуникационен протокол

След като базовата връзка работеше, беше въведен ясен протокол за обмен на данни:

- клиентът изпраща параметри (брой редове, колони и нишки);
- сървърът връща потвърждение, времена за изпълнение и визуализация на матрицата.

Всички операции по изпращане и получаване са капсулирани в методи като `sendInt`, `receiveInt`, `sendAll`, което подобрява четимостта и надеждността.

---

### 3. Реализация на матричните операции

След стабилизиране на комуникацията беше създаден клас `Matrix`, отговорен за:

- съхранение на матрицата;
- еднонишково запълване;
- многонишково запълване;
- генериране на текстов преглед на матрицата.

Това позволи ясно разделяне между мрежовата логика и изчислителната част.

---

### 4. Въвеждане на многонишкова обработка и thread pool

За да се обслужват множество клиенти едновременно, беше реализиран **thread pool**, който:

- приема задачи за обработка на клиенти;
- ограничава броя на активните нишки;
- подобрява мащабируемостта на сървъра.

Всеки клиент се обработва в отделна нишка, без създаване на нова нишка за всяка връзка.

---

### 5. Логиране и диагностика

Добавена беше централизирана логираща система, използваща singleton подход, която:

- записва събития с различни нива (INFO, DEBUG, ERR, etc.);
- улеснява откриването на грешки;
- позволява проследяване на жизнения цикъл на клиента и сървъра.

---

### 6. Обработка на грешки и защита от невалидни данни

В по-късен етап бяха добавени:

- проверки за валидност на входните данни от клиента;
- ограничения за размер на матрицата;
- защита при прекъсване на клиента по време на изчисления.

Тези мерки значително повишават устойчивостта на системата.

---

### 7. Graceful shutdown и RAII архитектура

Накрая беше реализирано коректно изключване на сървъра:

- прихващане на `Ctrl+C`;
- спиране на приемането на нови клиенти;
- изчакване на активните задачи да приключат;
- автоматично освобождаване на ресурси чрез RAII.

Сървърът е капсулиран в клас, който управлява жизнения си цикъл по безопасен начин.

---

### 8. Финални щрихи и документация

В последния етап бяха направени:

- подобрения в клиентския интерфейс;
- допълнителни проверки и логове;
- конфигурационен printout при стартиране;
- пълна документация на архитектурата и решенията.

---

### Забележка относно архитектурата

Благодарение на обектно-ориентирания дизайн и RAII подхода, отделните модули  
(`Socket`, `Server`, `Client`, `Matrix`, `ThreadPool`, `Logger`) са слабо свързани и могат да бъдат разработвани независимо. Реалната хронология на разработка обаче е продиктувана от логиката на проекта – първо стабилна комуникация, след това изчисления, паралелизация и накрая устойчивост и надеждност.


## Ограничения и бележки
- Проектът е Windows-only, тъй като използва Winsock2 за сокети.
- За да се наблюдава ускорение при мултитрединг, матриците трябва да са сравнително големи (≥1000x1000).
- Максимален брой елементи в матрицата: 100 000 000.

## Възможни подобрения / бонус функционалности
- Използване на selector/poll за асинхронно обработване на сокети.
- Контейнеризация чрез Docker (ограничение: Winsock).
- Събиране на статистики за производителността на сървъра при множество клиенти.
- Графично визуализиране на матрици.
- Логване на работата от страната на клиентите.

## Контакти и автор
Проектът е реализиран от Алекзандър Владимиров Владимиров.
Университетски проект за курс по Мрежово програмиране.

